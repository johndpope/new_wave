// Generated by CoffeeScript 1.7.1

/*
This function is called the first time that the Realtime model is created
for a file. This function should be used to initialize any values of the
model. In this case, we just create the single string model that will be
used to control our text box. The string has a starting value of 'Hello
Realtime World!', and is named 'text'.
@param model {gapi.drive.realtime.Model} the Realtime root model object.
 */

(function() {
  var Comment, KEYCODES, Thread, initializeModel, model, onFileLoaded, realtimeOptions, register_types, startRealtime;

  initializeModel = function(model) {
    var comments, root;
    root = model.getRoot();
    comments = model.createList();
    root.set('comments', comments);
  };


  /*
  This function is called when the Realtime file has been loaded. It should
  be used to initialize any user interface components and event handlers
  depending on the Realtime model. In this case, create a text control binder
  and bind it to our string model that we created in initializeModel.
  @param doc {gapi.drive.realtime.Document} the Realtime document.
   */

  KEYCODES = {
    enter: 13,
    backspace: 8
  };

  Thread = (function() {
    function Thread(_arg) {
      var comment, _i, _len, _ref;
      this.model = _arg.model, this.node = _arg.node;
      _ref = this.model.asArray();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        comment = _ref[_i];
        new Comment({
          model: comment,
          thread: this
        });
      }
      this.make_new_comment();
    }

    Thread.prototype.make_new_comment = function() {
      return this.new_comment = new Comment({
        thread: this
      });
    };

    Thread.prototype.render = function() {
      return this.node = $('<div class="replies"></div>');
    };

    Thread.prototype.post = function(comment) {
      this.model.push(comment.model);
      if (comment === this.new_comment) {
        return this.make_new_comment();
      }
    };

    Thread.prototype["delete"] = function(comment) {
      this.model.removeValue(comment.model);
      return comment.node.remove();
    };

    return Thread;

  })();

  Comment = (function() {
    function Comment(_arg) {
      var thread_model;
      this.model = _arg.model, this.thread = _arg.thread;
      this.render();
      if (this.model == null) {
        this.bind_new_comment_handlers();
      } else {
        this.bind_basic_handlers();
      }
      if (this.model == null) {
        this.create_model();
      }
      thread_model = this.model.get('thread');
      if (thread_model) {
        this.child_thread = new Thread({
          model: thread_model,
          node: this.thread_node
        });
      }
    }

    Comment.prototype.create_model = function() {
      return this.model = model.createMap({
        text: model.createString()
      });
    };

    Comment.prototype.render = function() {
      this.node = $('<div class="comment"></div>');
      this.text_node = $('<textarea></textarea>');
      this.node.append(this.text_node);
      this.thread.node.append(this.node);
      this.thread_node = $('<div class="thread"></div>');
      return this.node.append(this.thread_node);
    };

    Comment.prototype.bind_basic_handlers = function() {
      var delete_if_blank;
      gapi.drive.realtime.databinding.bindString(this.model.get('text'), this.text_node[0]);
      delete_if_blank = (function(_this) {
        return function(event) {
          if (event.which === KEYCODES.backspace && _this !== _this.thread.new_comment && !_this.text_node.val()) {
            return _this.thread["delete"](_this);
          }
        };
      })(this);
      this.text_node.on('keyup', delete_if_blank);
      if (this.child_thread == null) {
        return this.bind_threadless_handlers();
      }
    };

    Comment.prototype.bind_threadless_handlers = function() {
      var focus_new_thread;
      focus_new_thread = (function(_this) {
        return function(event) {
          var thread_model;
          if (event.which === KEYCODES.enter) {
            event.preventDefault();
            event.stopPropagation();
            thread_model = model.createList();
            _this.model.set('thread', thread_model);
            _this.child_thread = new Thread({
              model: thread_model,
              node: _this.thread_node
            });
            _this.child_thread.new_comment.text_node.focus();
            return _this.text_node.off('keypress', focus_new_thread);
          }
        };
      })(this);
      return this.text_node.on('keypress', focus_new_thread);
    };

    Comment.prototype.bind_new_comment_handlers = function() {
      var focus_new, spawn_next_comment;
      focus_new = (function(_this) {
        return function(event) {
          if (event.which === KEYCODES.enter) {
            event.preventDefault();
            event.stopPropagation();
            if (_this.text_node.val()) {
              _this.thread.new_comment.text_node.focus();
              _this.text_node.off('keypress', focus_new);
            }
            return false;
          }
        };
      })(this);
      this.text_node.on('keypress', focus_new);
      spawn_next_comment = (function(_this) {
        return function(event) {
          if (event.which !== KEYCODES.enter) {
            _this.thread.post(_this);
            _this.bind_basic_handlers();
            return _this.text_node.off('keypress', spawn_next_comment);
          }
        };
      })(this);
      return this.text_node.on('keypress', spawn_next_comment);
    };

    return Comment;

  })();

  register_types = function() {};

  model = null;

  onFileLoaded = function(doc) {
    var root, thread, thread_node;
    thread_node = $(document.body);
    model = doc.getModel();
    root = model.getRoot();
    thread = root.get('comments');
    new Thread({
      model: thread,
      node: thread_node
    });
  };


  /*
  Options for the Realtime loader.
   */


  /*
  Client ID from the console.
   */


  /*
  The ID of the button to click to authorize. Must be a DOM element ID.
   */


  /*
  Function to be called when a Realtime model is first created.
   */


  /*
  Autocreate files right after auth automatically.
   */


  /*
  The name of newly created Drive files.
   */


  /*
  The MIME type of newly created Drive Files. By default the application
  specific MIME type will be used:
  application/vnd.google-apps.drive-sdk.
   */


  /*
  Function to be called every time a Realtime file is loaded.
   */


  /*
  Function to be called to inityalize custom Collaborative Objects types.
   */


  /*
  Function to be called after authorization and before loading files.
   */


  /*
  Start the Realtime loader with the options.
   */

  startRealtime = function() {
    var realtimeLoader;
    realtimeLoader = new rtclient.RealtimeLoader(realtimeOptions);
    realtimeLoader.start();
  };

  realtimeOptions = {
    clientId: "750901531017-tr6fb08mn5kacnd1suht48uj8762dkc5.apps.googleusercontent.com",
    authButtonElementId: "authorizeButton",
    initializeModel: initializeModel,
    autoCreate: true,
    defaultTitle: "New Wave2",
    newFileMimeType: null,
    onFileLoaded: onFileLoaded,
    registerTypes: register_types,
    afterAuth: null
  };

  startRealtime();

}).call(this);
